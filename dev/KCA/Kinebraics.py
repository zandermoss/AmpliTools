#! /usr/bin/python

import sympy
from sympy import *
from tqdm import tqdm
from SymPyTools import IsSympySymbolic, IsSympy, FuncType

class Kinebraics():
	"""
	When presented with a vanishing condition for some expression which 
	mixes kinematic and algebraic data (like a diagrammatic expansion
	of an amplitude or a laurent coefficient thereof), we can deduce
	constraints on the algebraic symbols by splitting the sum into 
	terms which factorize into kinematic and algebraic factors (where possible).
	We represent this separated sum as a dictionary with purely kinematic 
	expressions as keys and purely algebraic expressions as values. This is 
	self.kinebraic_dict. Get it!?!?
	When the keys are independent under all available kinematic identities.
	we can conclude that the values all must vanish identically, yielding 
	a system of constraints on the algebraic symbols.  
	The keys resulting will be independent under on-shell, ward, and 
	momentum-conservation identities. However, they will generally be 
	rational functions of the kinematic invariants, so there may be factorizations
	or cancellations that can be performed on a pair of apparently unequal keys
	which will demonstrate their equality. To eliminate this possibility, we
	refine self.kinebraic_dict in three stages.

	1) At the point of conversion from a mixed sympy expression, we should have
		distributed sums in the keys to entries keyed over the terms in each 
		such sum. It follows that the remaining keys are either symbols, numbers,
		products, or powers. If there are any negative powers, we clear these out
		by multiplying each key by the least common denominator of all keys.
		This procedure is encapsulated in self.ClearDenominators().
	
	2) Now, each of the remaining (positive-power) factors may or may not be sums.
		To avoid factorization ambiguities, we expand all products in each
		kinematic key. This is done by self.KinematicExpansion().

	3) Next, we define a new dictionary keyed by all the terms in each sum key.
		
	4) Finally, we move numerical prefactors from the kinematic key to the
		algebraic value. 

	Finally, we have isolated a relation polynomial in the kinematic invariants.
	The algebraic coefficients of each such monomial must vanish independently.
	"""

	def __init__(self,arg,covariant):
		"""
		Fix kinematic_prefixes to covariance preserving or covariance breaking forms.
		Then, either initialize from kinebraic dict or from sympy expression.
		"""
		self.covariant = covariant	
	
		if covariant:
			self.kinematic_prefixes = ['pp', 'pe', 'pl', 'ee', 'le', 'll']
		else:
			self.kinematic_prefixes = ['pp3','pe3','ee3']

		if type(arg)==type({}):
			self.InitDict(arg)
		elif IsSympy(arg):
			self.InitSympy(arg)
		else:
			assert False, "Bad argument to __init__. Need either kinebraic_dict or Sympy expression."


	def InitSympy(self,expr):
		"""
		Construct from sympy expression.
		Attempt to split the sympy expr into a vector with coefficients in the field generated by the coefficient
		and the complex rationals. The basis elements lie in the field generated by the kinematic invariants and the
		complex rationals. The set of these invariants depends on whether we are using the d+1 covariant formulation 
		or the d,1 non-covariant formulation. If the expression cannot be split (expected for high-point amplitudes 
		in soft limit), we'll assert false.
		"""
	
		#Initialize the splitting dict. keys are purely kinematic expressions, values are purely algebraic.
		#Entries are terms in the amplitude.
		self.kinebraic_dict = {}
	
		#Expand first
		if IsSympySymbolic(expr):
			expr = expr.expand()

		#Sum over terms in the amplitude and fill the dictionary.
		if FuncType(expr)=="add":
			for term in expr.args:
				kinematic_factor,algebraic_factor = self.Split(term)
				self.kinebraic_dict.setdefault(kinematic_factor, 0)
				self.kinebraic_dict[kinematic_factor]+=algebraic_factor

		#If single term, skip the loop and fill the dict with a single entry.
		else:
			kinematic_factor,algebraic_factor = self.Split(expr)
			self.kinebraic_dict[kinematic_factor] = algebraic_factor
		
		#Distribute sums into kinebraic_dict.
		self = self.DistributeSum()

	def InitDict(self,mydict):
		"""
		Construct from kinebraic dict.
		"""
		self.kinebraic_dict = mydict


	def IsKinematic(self,expr):
		"""
		Determine whether an expression contains kinematic invariants.
		"""
		for prefix in self.kinematic_prefixes:
			if prefix+"_{" in expr.__str__():
				return True
		return False

	def KinematicContent(self,expr):
		"""
		Determine whether an expression contains purely kinematic symbols.
		purely algebraic symbols, or a mixture of the two.
		"""
		symbol_bools = [self.IsKinematic(sym) for sym in expr.free_symbols]
		#Handle case that expr is a complex number.
		if symbol_bools == []:
			return "algebraic"
		elif all(symbol_bools):
			return "kinematic"
		else:
			if any(symbol_bools):
				return "mixed"
			else:
				return "algebraic"

	def SplitPure(self,expr):
		"""
		Assuming [expr] is purely algebraic or kinematic, return factors. Otherwise, raise assertion.
		"""
		content = self.KinematicContent(expr)
		if content=="algebraic":
			return 1,expr
		elif content=="kinematic":
			return expr,1
		else:
			assert False,"Term is mixed and does not decompose. Can't handle this case."

	def Split(self,expr):
		"""
		Split the term into kinematic and algebraic factors. If not possible, assert False.
		"""
		#MULT 
		if FuncType(expr)=="mul":
			kinematic_factor = 1
			algebraic_factor = 1
			for factor in expr.args:
				kin,alg = self.Split(factor)
				kinematic_factor *= kin
				algebraic_factor *= alg
			return kinematic_factor,algebraic_factor

		#POW
		elif FuncType(expr)=="pow":
			power = expr.args[1]
			#Integer power expressions can be split.
			if power.is_integer:
				kin,alg = self.Split(expr.args[0])
				return kin**power,alg**power
			#Non-integer power expressions cannot.
			else:	
				return self.SplitPure(expr)

		#SUM
		elif FuncType(expr)=="add":
			#If we encounter a sum, we'll try to factor it.
			factored_expr = expr.factor()
			#If factorization failed, check composition and return.
			if FuncType(factored_expr)=="add":
				return self.SplitPure(factored_expr)
			#Did factorization succeed? If so, split the factors.
			else:
				return self.Split(factored_expr)	

		#ELSE
		else:
			#We're at a number, a symbol, or some non-algebraic function. Can't decompose further, 
			#check composition and return (this is the base case).
			return self.SplitPure(expr)

	def ExtractDenominators(self,expr):
		"""
		Given an expression not of type 'add' (that is, given a factor of some
		expression or a term in a sum), return a dictionary of factors of the
		denominator of this expression. Format is {key=factor:val=power of that
		factor}.
		"""
		assert FuncType(expr)!="sum","Forgot to distribute sums!"
		denominators = {}
		#MULT 
		if FuncType(expr)=="mul":
			for factor in expr.args:
				if FuncType(factor)=="pow":
					power = factor.args[1]
					if power<0:
						denominators.setdefault(factor.args[0],0)
						denominators[factor.args[0]]+=abs(power)
					else:
						pass
				else:
					pass

		#POW
		elif FuncType(expr)=="pow":
			power = expr.args[1]
			if power<0:
				denominators.setdefault(expr.args[0],0)
				denominators[expr.args[0]]+=abs(power)
			else:
				pass

		#ELSE
		else:
			#We're at a number, a symbol, or some non-algebraic function. Can't decompose further, 
			pass
		return denominators

	def LeastCommonDenominator(self):
		"""
		Compute the denominators dictionaries for each kinematic key in
		self.kinebraic_dict. Take the maximum power of each factor present
		and return the corresponding dictionary, which represents the least 
		common *kinematic* denominator corresponding to the expression 
		represented by self.kinebraic_dict.
		"""
		denominators = []
		for kin in self.kinebraic_dict.keys():
			term_denominator = self.ExtractDenominators(kin)
			denominators.append(term_denominator)

		unified_denominators = {}
		for denom in denominators:
			for key,val in denom.items():
				unified_denominators.setdefault(key,[])
				unified_denominators[key].append(val)

		lcd = {}
		for key,val in unified_denominators.items():
			lcd[key] = max(val)

		return lcd
			

	def ClearExprDenominators(self,expr,lcd):
		"""
		Use the least common denominator dictionary computed above to clear out
		denominators of a given kinematic key expression. Numerator is multiplied
		by the remaining lcm factors.
		"""
		my_lcd = dict(lcd)
		assert FuncType(expr)!="add","Forgot to distribute sums!"
		cleared_expr = 1
		#MULT 
		if FuncType(expr)=="mul":
			for factor in expr.args:
				if FuncType(factor)=="pow":
					power = factor.args[1]
					if power<0:
						if factor.args[0] in my_lcd.keys():
							my_lcd[factor.args[0]]-=abs(power)
						else:
							cleared_expr*=factor
					else:
						cleared_expr*=factor
				else:
					cleared_expr*=factor

		#POW
		elif FuncType(expr)=="pow":
			power = expr.args[1]
			if power<0:
				if expr.args[0] in my_lcd.keys():
					my_lcd[expr.args[0]]-=abs(power)
				else:
					cleared_expr*=expr
			else:
				cleared_expr*=expr
		#ELSE
		else:
			#We're at a number, a symbol, or some non-algebraic function. Can't decompose further, 
			cleared_expr*=expr

		for key,val in my_lcd.items():
			cleared_expr*=key**val

		return cleared_expr


	def ClearDenominators(self):
		"""
		Use lcm of all kinematic keys of self.kinebraic_dict to clear out all
		denominators of kinematic keys. Return a Kinebraics object with 
		all cleared kinematic keys, as well as a copy of lcd. 
		"""

		cleared_kinebraic_dict = {}
		lcd = self.LeastCommonDenominator()
		for kin,alg in self.kinebraic_dict.items():
			cleared_kin = self.ClearExprDenominators(kin,lcd)
			cleared_kinebraic_dict.setdefault(cleared_kin,0)
			cleared_kinebraic_dict[cleared_kin]+=alg
		return Kinebraics(cleared_kinebraic_dict,self.covariant),lcd


	def KinematicExpansion(self):
		"""
		Expand all products in the kinematic keys of self.kinebraic dict.
		"""
		expanded_kinebraic_dict = {}
		for kin,alg in self.kinebraic_dict.items():
			if IsSympySymbolic(kin):
				expanded_kin = kin.expand()
			else:
				expanded_kin = kin
			expanded_kinebraic_dict.setdefault(expanded_kin,0)
			expanded_kinebraic_dict[expanded_kin]+=alg
		return Kinebraics(expanded_kinebraic_dict,self.covariant)

	def DistributeSum(self):
		"""
		Redistribute dictionary entries keying by the terms in the kinematic
		keys. 
		"""
		kinebraic_dict = {}
		for kin,alg in self.kinebraic_dict.items():
			if (not IsSympySymbolic(kin)):
				sumtype = False
			else:
				sumtype = FuncType(kin)=="add"
			if sumtype:
				for term in kin.args:
					kinebraic_dict.setdefault(term,0)
					kinebraic_dict[term]+=alg
			else:
				kinebraic_dict.setdefault(kin,0)
				kinebraic_dict[kin]+=alg
		return Kinebraics(kinebraic_dict,self.covariant)

	def SwapPreFactors(self):
		"""
		Swap non-symbolic prefactors in kinematic keys to the algebraic values
		and redistribute with the new, stripped keys.
		"""
		kinebraic_dict = {}
		for kin,alg in self.kinebraic_dict.items():
			#if IsSympySymbolic(kin):
			#	factored_kin = kin.factor()
			#else:	
			#	factored_kin = kin
			factored_kin = kin
			if FuncType(factored_kin)=="mul":
				newkin=1
				algfac=1
				for factor in factored_kin.args:
					if IsSympySymbolic(factor):
						newkin*=factor
					else:
						algfac*=factor
			else:
				newkin = kin
				algfac = 1
			
			kinebraic_dict.setdefault(newkin,0)
			kinebraic_dict[newkin]+=algfac*alg

		return Kinebraics(kinebraic_dict,self.covariant)
				
	def ToKinematicPolynomial(self):
		"""
		Perform the four-step processing described in the header comment of
		the Kinebraics class. Return a Kinebraics object representing a 
		polynomial over the kinematic invariants.
		"""
		kinebraics,lcd = self.ClearDenominators()
		kinebraics = kinebraics.KinematicExpansion()
		kinebraics = kinebraics.DistributeSum()
		kinebraics = kinebraics.SwapPreFactors()
		return kinebraics,lcd

	def ReduceRedundantConstraints(self):
		"""
		Strip numeric factors off of the algebraic entries. This doesn't alter
		a relation where this kinebraic object is set equal to zero *and*
		the kinebraic object has already been reduced to a kinematic polynomial
		using ToKinematicPolynomial(). Accumulates the algebraic constraints
		and eliminates redundancies.	
		"""
		algebraic_constraints = []
		for constraint in self.kinebraic_dict.values():
			#if IsSympySymbolic(constraint):
			#	factored_constraint = constraint.factor()
			#else:	
			#	factored_constraint = constraint
			factored_constraint = constraint
			if FuncType(factored_constraint)=="mul":
				stripped_constraint = 1
				for factor in factored_constraint.args:
					if IsSympySymbolic(factor):
						stripped_constraint *= factor
			else:
				stripped_constraint = factored_constraint
				
			#algebraic_constraints.append(stripped_constraint.simplify())
			algebraic_constraints.append(stripped_constraint)
		return list(set(algebraic_constraints))

	def __str__(self):
		string = ""
		for kin,alg in self.kinebraic_dict.items():
			string+=str(kin)+" : "+str(alg)+"\n"
		return string
